' Gambas class file

' CJSON -- Class to Read and parse a JSON file into a collection
' Try to implement https://goessner.net/articles/JsonPath/
' As a gambas program. Add this path searching functionality to this class.

' Event to send data to calling program for representation in a Tree View or other hierarchical representation.
Event Added(key As String, name As String, value As String, type As String)

Event DebugMessage(msg As String, Level As Integer)
Event OpenedURL(url As String)

' 00h = 05h are json types
' 10h - 12h are modes local file, internet url, or text assigned to property
Public Enum local = &H10, {net} = &H11, {text} = &H12, {object} = &H05, {array} = &H04, {string} = &H03, {number} = &H02, {boolean} = &H01, {null} = &H00, {invalid_json_type} = -1

' Read Only Properties
Property Read {Type} As Integer ' Returns a type from the above enum for the root document.
Property Read NamedType As String 'Returns a string that describes the Type property
Property Read Value As Variant ' Returns the default value or root document
Property Read Objects As Integer ' Returns the number of objects in the JSON
Property Read {Arrays} As Integer ' Returns the number of Arrays in the JSON
Property Read Members As Integer ' Returns total number of members i.e., "key" : "value"

' Read/Write Properties

Property {URL} As String
Property LineNoWidth As Integer
Property {Debug} As Integer ' implement debug levels

Private m_text As String
Private m_url As String
Private m_raw_json_object As Variant
Private m_json_col As New Collection
Private m_js_type As Integer ' Type of JSON data at the root as described on the right margin at https://www.json.org/
' count of objects and arrays. Open and close counts allow for further validation.
Private m_object_open_count As Integer
Private m_object_close_count As Integer
Private m_array_open_count As Integer
Private m_array_close_count As Integer
Private m_members_count As Integer
Private m_line_no As Integer
Private m_line_no_width As Integer = 4 ' Amount of padding for hexidecimal representation of line numbers. Also sets padding for array and object open locations.
Private m_debug As Integer = 1 ' TODO: implement this with different debug levels to be set from the implementation level (public property)
Public Function FindByKey(pKey As String) As Variant
  Print "Building search string from: " & pKey
  ' Dim key_len As Integer = 0 'Length of key to current token.
  Dim curr_key As String
  
  Dim SplitKey As New String[]
  Dim l_json_array As String[]
  Dim l_json_item As String
  If pKey = "/" Then Return m_raw_json_object
  l_json_array = Split(pKey, "/")
  For Each l_json_item In l_json_array
      If l_json_item = "" Then 
       l_json_item = "/"
       curr_key = "/"
      Else If curr_key = "/" Then
        curr_key &= l_json_item
      Else
        curr_key &= "/" & l_json_item
      Endif
      If GetValueFromPath(curr_key) = "[" Then ' Like "*\\[[0-9]\\]" Then 
        ' Process array here
        Print "Found Array: " & curr_key  ' An array, parse out the element use an array element of a variant
      Else If GetValueFromPath(curr_key) = "{" Then
        Print "Found Object: " & curr_key
        If l_json_item Like "*\\[*\\]" Then Print "This Object is an Array element."
      Else
        Print "Found Object Member: " & l_json_item & " => " & GetValueFromPath(curr_key)
        
      End If
      
    Print "Adding : " & l_json_item & " => " & GetValueFromPath(curr_key)
    SplitKey.Add(l_json_item)
  Next
 Return 
End

Public Function GetValueFromPath(pKey As String) As Variant
  
  Return m_json_col[pKey]
  
End

Public Sub Clear()
  ' Method Clear
  ' Clears the internal collection of JSON information
  ' blanks the file name
  ' Resets object and array open and close counts
  ' Clears text
  ' sets type to null
  
  m_object_open_count = 0
  m_object_close_count = 0
  m_array_open_count = 0
  m_array_close_count = 0
  m_members_count = 0
  m_line_no = 0
  m_url = ""
  m_text = ""
  m_js_type = Me.null
  m_json_col.Clear()

End

Public Function Open() As Integer
  ' Method Read as Integer
  ' Reads a JSON file with File.Load
  ' Return 0 for success
  ' Returns Error codes in the Future
  Dim js As JSONCollection
  Dim vBuffer As Variant ' variable to hold JSON data while determining the type
   
  m_text = File.Load(m_url)
  Raise OpenedURL(m_url)
  vBuffer = JSON.Decode(m_text, True)
  m_raw_json_object = vBuffer
  m_js_type = parse(vBuffer, "/") ' We will make this work like XPath or like any other path we work with 
  
End

Public Function JSONType(vBuffer As Variant) As Integer
' Takes a Decoded JSON Array or Object and returns the type from the enum
 
 Dim ret_val As Integer
 
 Select Case TypeOf(vBuffer)
    Case gb.Boolean
      ret_val = Me.boolean
     
    Case gb.Integer
      ret_val = Me.number

    Case gb.Single
      ret_val = Me.number
      
    Case gb.Float
      ret_val = Me.number
      
    Case gb.String
      ret_val = Me.string
 
    Case gb.Null
      ret_val = Me.null
 
    Case gb.Object
      If vBuffer Is Collection Then 
        ret_val = Me.object

      Else If vBuffer Is Variant[] Then
        ret_val = Me.array

      Else
        ret_val = Me.invalid_json_type
        Raise DebugMessage("Ignoring Unknown Type at line " & Hex(m_line_no, m_line_no_width), LogLevel.Warning)
        
      Endif
      Case Else
        ret_val = Me.invalid_json_type
        Raise DebugMessage("Ignoring Unknown Type at line " & Hex(m_line_no, m_line_no_width), LogLevel.Warning)
  End Select
  
  Return ret_val
  
End



Public Function parse(vBuffer As Variant, pParent As String, Optional pName As String, Optional pArrayEl As String) As Integer
' Method Parse as Integer
' Parses JSON data down to a valid value as listed on https://www.json.org/
' Also keeps track of the hierarcy of the file with a path
' Unnamed arrays (i.e., the root array if found) is only named as a number
' Named array elements are followed by the ordinal of their array position
' Returns a JSTYPE
' Moved some repetive functionality to the subroutine AddMember
' !!!! This function is recursive. Make certain to keep it so !!!!

' temp buffers
Dim jsBuffer As Collection
Dim vBuf As Variant
Dim sBuffer As String
' counter variable
Dim iii As Integer
' reutrn buffer
Dim ret_val As Integer
' other counters
Dim object_close_line As String
Dim object_no As Integer
Dim array_close_line As String
Dim array_no As Integer
Dim next_key As String
Dim next_name As String
Dim block_name As String ' Name of current object or array
Dim display_name As String ' Name of object or array to be displayed in GUI

 ret_val = JSONType(vBuffer)
 Select Case ret_val
    Case Me.boolean

      sBuffer = IIf(CBool(vBuffer), "True", "False")
      'ret_val = Me.boolean
      AddMember(pParent, pName, sBuffer, ret_val)
      
    Case Me.number

      sBuffer = CStr(vBuffer)
      ' ret_val = Me.number
      AddMember(pParent, pName, sBuffer, ret_val)

    ' Case gb.Single
    ' 
    '   sBuffer = CStr(vBuffer)
    '   ret_val = Me.number
    '   AddMember(pParent, pName, sBuffer, ret_val)
    '   
    ' Case gb.Float
    ' 
    '   sBuffer = CStr(vBuffer)
    '   ret_val = Me.number
    '   AddMember(pParent, pName, sBuffer, ret_val)
    '   
    Case Me.string

      sBuffer = "\"" & CStr(vBuffer) & "\""
      ' ret_val = Me.string
      AddMember(pParent, pName, sBuffer, ret_val)
      
    Case Me.null

      sBuffer = "null"
      ' ret_val = Me.null
      AddMember(pParent, pName, sBuffer, ret_val)
      
    Case Me.object
      ' If vBuffer Is Collection Then 
        m_json_col.Default = IIf(pParent = "", vBuffer, m_json_col.Default)
        m_line_no += 1
        m_object_open_count += 1

        ' Set the name of the current block we are in.
        block_name = Right(pParent, Len(pParent) - RInStr(pParent, "/")) 
        If block_name = "" Then
          next_key = pParent & pName & pArrayEl
        Else
          next_key = pParent & pArrayEl
        Endif
        ' block_name = IIf(block_name = "", pName, block_name)      
        block_name &= pArrayEl

        ' If m_debug Then
        '   object_close_line = Hex$(m_line_no, m_line_no_width)
        '   Raise DebugMessage(Hex$(m_line_no, m_line_no_width) & " | " & pParent & "/" & m_object_open_count & "{  : " & m_object_open_count & "{ ", LogLevel.Info)
        '   Raise DebugMessage("Found Object Block named " & block_name, LogLevel.Info)
        ' Endif
        
        ' Setup name to display in the TreeView
        ' next_name = block_name & "{"
        
        ' next_key = pParent & pArrayEl & '"{" '   Right$(pArrayEl, Len(pArrayEl) - 1) ' & "{" ' 
        display_name = block_name
        ' next_key = pParent & IIf(display_name = "$", "", display_name)
        AddMember(next_key, display_name, "{", Me.object)
        
        For Each vBuf In VBuffer
          ' If m_debug Then Raise DebugMessage(" Block name " & block_name & " Contains " & vBuffer.key & " : ", LogLevel.Info)
          
          parse(vBuf, IIf(next_key = "/", next_key, next_key & "/") & vBuffer.key, vBuffer.key) ' why this function is recursive
        Next
        
        m_line_no += 1
        m_object_close_count += 1
        
        ' If m_debug Then 
        '   Raise DebugMessage(Hex$(m_line_no, m_line_no_width) & " | " & pParent & "/" & object_no & "} from line " & object_close_line, LogLevel.Info)
        '   object_close_line = ""
        ' Endif
        
        ' next_name = "}" & block_name
        next_key &= "~" 'pParent & "}" & pArrayEl ' Right(pArrayEl, Len(pArrayEl) - 1) ' "}" & 
        display_name = block_name
        ' next_key = pParent & "}" & IIf(display_name = "$", "", display_name)
        AddMember(next_key, display_name, "}", Me.object)

        ' ret_val = Me.object
      ' Else If vBuffer Is Variant[] Then
      Case Me.array
        
        m_json_col.Default = IIf(pParent = "", vBuffer, m_json_col.Default)
        m_line_no += 1
        m_array_open_count += 1
                
        array_no = m_array_open_count
        block_name = Right(pParent, Len(pParent) - RInStr(pParent, "/")) ' name of current block
        ' 
        ' If m_debug Then 
        '   array_close_line = Hex$(m_line_no, m_line_no_width)
        '   Raise DebugMessage(Hex$(m_line_no, m_line_no_width) & " | " & pParent & "/" & array_no & "[ : " & m_array_open_count & "[", LogLevel.Info)
        '   Raise DebugMessage("Found Array Block named " & block_name, LogLevel.Info)
        ' Endif

        next_key = pParent '& "[" 
        next_name = IIf(block_name = "", next_name, next_name & block_name)
        ' Raise Added(next_key, next_name, "[", "Array")
        ' m_json_col.Add("[", next_key)
        AddMember(next_key, next_name, "[", Me.array)
        
        iii = 0
        For Each jsbuffer In vBuffer
          ' If m_debug Then Raise DebugMessage("Array position " & iii & " in block named " & block_name, LogLevel.Info)
          parse(jsBuffer, next_key, next_name, "[" & iii & "]")
          iii += 1
        Next
        m_line_no += 1
        m_array_close_count += 1
        
        ' If m_debug Then 
        '   Raise DebugMessage(Hex(m_line_no, m_line_no_width) & " | " & pParent & "/" & array_no & "] from line " & array_close_line, LogLevel.Info)
        '   array_close_line = ""
        ' Endif

        next_key = pParent & "~" 
        next_name = IIf(block_name = "", next_name, block_name)
        
        ' Raise Added(next_key, next_name, "]", "Array")
        ' m_json_col.Add("]", next_key)
        AddMember(next_key, next_name, "]", Me.array)
        
        ' ret_val = Me.array
      Case Else
   
        ' Print "Unknown?"
        Raise DebugMessage("Ignoring Unknown Type at line " & Hex(m_line_no, m_line_no_width), LogLevel.Warning)
        
      ' Endif
  End Select
 Return ret_val
End

Private Sub AddMember(pKey As String, pName As String, pValue As String, pType As Integer)
' Added to clean up some code, make it more readable and easier to maintain
' this is the repetitive functions found in the Select Case tree in function parse.
' I also set this up so in the future debugging can be turned on and off easier
      Dim sType As String
      m_line_no += 1
      ' These strings for the types must match what is in the icon collection. consider moving the collection of icons to this class.
      sType = Choose(pType, "Boolean", "Number", "String", "Array", "Object")
      sType = IIf(sType = Null, "Null", sType)
      pKey = IIf(pKey = "", "/", pKey) ' Make sure key value is not null
      ' If m_debug Then Raise DebugMessage(Hex(m_line_no, m_line_no_width) & " | " & pKey & " ==> \"" & pName & "\" : " & pValue, LogLevel.Info)
      Raise Added(pKey, pName, pValue, sType)
      m_json_col.Add(pValue, pKey)
      m_json_col.Default = IIf(m_members_count = 0, pValue, m_json_col.Default)
      m_members_count += 1
  
End


Private Function Value_Read() As Variant

  Return m_json_col.Default

End


Private Function Objects_Read() As Integer
'Returns the count or -1 if there is an error
  Return IIf(m_object_open_count - m_object_close_count = 0, m_object_close_count, -1)

End

Private Function Arrays_Read() As Integer
' Returns the number of arrays in the JSON or -1 if there is an error
  Return IIf(m_array_open_count - m_array_close_count = 0, m_array_close_count, -1)

End

Private Function NamedType_Read() As String

  Dim sBuffer As String
  
  sBuffer = Choose(m_js_type, "Boolean", "Number", "String", "Array", "Object")
  sBuffer = IIf(sBuffer = Null, "null", sBuffer)
  Return sBuffer

End

Private Function Members_Read() As Integer

  Return m_members_count

End


Function Type_Read() As Integer
  
  Return m_js_type
  
End

Private Function URL_Read() As String

  Return m_url

End

Private Sub URL_Write(Value As String)

  m_url = Value

End

Private Function LineNoWidth_Read() As Integer

  Return m_line_no_width

End

Private Sub LineNoWidth_Write(Value As Integer)

  m_line_no_width = Value

End

Private Function Debug_Read() As Integer

  Return m_debug

End

Private Sub Debug_Write(Value As Integer)

  m_debug = Value

End
