' Gambas class file

' CJSON -- Class to Read and parse a JSON file into a collection


' Event to send data to calling program for representation in a Tree View or other hierarchical representation.
Event Added(key As String, name As String, value As String, type As String)

Event DebugMessage(msg As String, iLevel As Integer)

' 00h = 05h are json types
' 10h - 12h are modes local file, internet url, or text assigned to property
Public Enum local = &H10, {net} = &H11, {text} = &H12, {object} = &H05, {array} = &H04, {string} = &H03, {number} = &H02, {boolean} = &H01, {null} = &H00

' Read Only Properties
Property Read {Type} As Integer ' Returns a type from the above enum for the root document.
Property Read NamedType As String 'Returns a string that describes the Type property
Property Read Value As Variant ' Returns the default value or root document
Property Read Objects As Integer ' Returns the number of objects in the JSON
Property Read {Arrays} As Integer ' Returns the number of Arrays in the JSON
Property Read Members As Integer ' Returns total number of members i.e., "key" : "value"

' Read/Write Properties

Property {URL} As String
Property LineNoWidth As Integer
Property {Debug} As Integer ' implement debug levels

Private m_text As String
Private m_url As String
Private m_json_col As New Collection
Private m_js_type As Integer ' Type of JSON data at the root as described on the right margin at https://www.json.org/
' count of objects and arrays. Open and close counts allow for further validation.
Private m_object_open_count As Integer
Private m_object_close_count As Integer
Private m_array_open_count As Integer
Private m_array_close_count As Integer
Private m_members_count As Integer
Private m_line_no As Integer
Private m_line_no_width As Integer = 4 ' Amount of padding for hexidecimal representation of line numbers. Also sets padding for array and object open locations.
Private m_debug As Integer = 1 ' TODO: implement this with different debug levels to be set from the implementation level (public property)

Public Function GetNameFromPath(pKey As String) As Variant
  
  Return m_json_col[pKey]
  
End



Public Sub Clear()
  ' Method Clear
  ' Clears the internal collection of JSON information
  ' blanks the file name
  ' Resets object and array open and close counts
  ' Clears text
  ' sets type to null
  
  m_object_open_count = 0
  m_object_close_count = 0
  m_array_open_count = 0
  m_array_close_count = 0
  m_members_count = 0
  m_line_no = 0

  m_url = ""
  m_text = ""
  m_js_type = Me.null
  m_json_col.Clear()
  
  
End



Public Function Open() As Integer
  ' Method Read as Integer
  ' Reads a JSON file with File.Load
  ' Return 0 for success
  ' Returns Error codes in the Future
  Dim js As JSONCollection
  Dim vBuffer As Variant ' variable to hold JSON data while determining the type
  
 ' If fname = "" Then fname = m_url
 ' m_url = fname 
  m_text = File.Load(m_url)
  vBuffer = JSON.Decode(m_text, False)
  m_js_type = parse(vBuffer, "")
  
 ' Print TypeOf() & " in file " & m_curr_file

End

Public Function parse(vBuffer As Variant, pParent As String, Optional pName As String) As Integer
' Method Parse as Integer
' Parses JSON data down to a valid value as listed on https://www.json.org/
' Also keeps track of the hierarcy of the file with a path
' Unnamed arrays (i.e., the root array if found) is only named as a number
' Named array elements are followed by the ordinal of their array position
' Reutrns a JSTYPE
' Moved some repetive functionality to the subroutine AddMember
' !!!! This function is recursive. Make certain to keep it so !!!!

' temp buffers
Dim jsBuffer As Collection
Dim vBuf As Variant
Dim sBuffer As String
' counter variable
Dim iii As Integer
' reutrn buffer
Dim ret_val As Integer
' other counters
Dim object_close_line As String
Dim object_no As Integer
Dim array_close_line As String
Dim array_no As Integer
Dim next_key As String
Dim next_name As String
Dim block_name As String ' Name of current object or array
Dim display_name As String ' Name of object or array to be displayed in GUI

 Select Case TypeOf(vBuffer)
    Case gb.Boolean

      sBuffer = IIf(CBool(vBuffer), "True", "False")
      ret_val = Me.boolean
      AddMember(pParent, pName, sBuffer, ret_val)
      
    Case gb.Integer

      sBuffer = CStr(vBuffer)
      ret_val = Me.number
      AddMember(pParent, pName, sBuffer, ret_val)

    Case gb.Single

      sBuffer = CStr(vBuffer)
      ret_val = Me.number
      AddMember(pParent, pName, sBuffer, ret_val)
      
    Case gb.Float

      sBuffer = CStr(vBuffer)
      ret_val = Me.number
      AddMember(pParent, pName, sBuffer, ret_val)
      
    Case gb.String

      sBuffer = "\"" & CStr(vBuffer) & "\""
      ret_val = Me.string
      AddMember(pParent, pName, sBuffer, ret_val)
      
    Case gb.Null

      sBuffer = "null"
      ret_val = Me.null
      AddMember(pParent, pName, sBuffer, ret_val)
      
    Case gb.Object
      If vBuffer Is Collection Then 
        m_json_col.Default = IIf(pParent = "", vBuffer, m_json_col.Default)
        m_line_no += 1
        m_object_open_count += 1
        
        block_name = Right(pParent, Len(pParent) - RInStr(pParent, "/")) ' name of current block
              
        If m_debug Then
          Raise DebugMessage(Hex$(m_line_no, m_line_no_width) & " | " & pParent & "/" & m_object_open_count & "{  : " & m_object_open_count & "{ ", LogLevel.Info)
          Raise DebugMessage("Found Object Block named " & block_name, LogLevel.Info)
          ' Print Hex(m_line_no, m_line_no_width) & " | " & pParent & "/" & m_object_open_count & "{  : " & m_object_open_count & "{ "
          ' Print "Found Object Block named " & block_name 
        Endif
        
       
        object_no = m_object_open_count
        object_close_line = Hex$(m_line_no, m_line_no_width)
        next_name = "{" & object_no & "}{"
        next_key = pParent & next_name
        display_name = IIf(block_name = "", next_name, block_name)
        next_name = next_name & block_name
        Raise Added(next_key, display_name, "{", "Object")
        m_json_col.Add(next_name, next_key)
        
        For Each vBuf In VBuffer
          If m_debug Then Raise DebugMessage(" Block name " & block_name & " Contains " & vBuffer.key & " : ", LogLevel.Info)
          parse(vBuf, next_key & "/" & vBuffer.key, vBuffer.key) ' why this function is recursive
        Next
        m_line_no += 1
        m_object_close_count += 1
        
       If m_debug Then Raise DebugMessage(Hex$(m_line_no, m_line_no_width) & " | " & pParent & "/" & object_no & "} from line " & object_close_line, LogLevel.Info)
       next_name = "}{" & object_no & "}" 
       next_key = pParent & next_name
       display_name = IIf(block_name = "", next_name, block_name)
       next_name = next_name & block_name
       Raise Added(next_key, display_name, "}", "Object")
        m_json_col.Add(next_name, next_key)
        object_close_line = ""
        ret_val = Me.object
      Else If vBuffer Is Variant[] Then
        m_json_col.Default = IIf(pParent = "", vBuffer, m_json_col.Default)
        m_line_no += 1
        m_array_open_count += 1
        array_close_line = Hex(m_line_no, m_line_no_width)
        array_no = m_array_open_count
        block_name = Right(pParent, Len(pParent) - RInStr(pParent, "/")) ' name of current block
        
        If m_debug Then 
          Raise DebugMessage(Hex$(m_line_no, m_line_no_width) & " | " & pParent & "/" & array_no & "[ : " & m_array_open_count & "[", LogLevel.Info)
          Raise DebugMessage("Found Array Block named " & block_name, LogLevel.Info)
          ' Print Hex(m_line_no, m_line_no_width) & " | " & pParent & "/" & array_no & "[ : " & m_array_open_count & "["
          ' Print "Found Array Block named " & block_name 
        Endif
        
        next_name = "[" & array_no & "][" 
        next_key = pParent & next_name
        next_name = IIf(block_name = "", next_name, next_name & block_name)
        Raise Added(next_key, next_name, "[", "Array")
        m_json_col.Add(next_name, next_key)
        
        iii = 1
        For Each jsbuffer In vBuffer
          If m_debug Then Raise DebugMessage("Array position " & iii & " in block named " & block_name, LogLevel.Info)
          parse(jsBuffer, next_key & "/")
          iii += 1
        Next
        m_line_no += 1
        m_array_close_count += 1
        
        If m_debug Then Raise DebugMessage(Hex(m_line_no, m_line_no_width) & " | " & pParent & "/" & array_no & "] from line " & array_close_line, LogLevel.Info)
        next_name = "][" & array_no & "]"
        next_key = pParent & next_name
        next_name = IIf(block_name = "", next_name, next_name & block_name)
        Raise Added(next_key, next_name, "]", "Array")
        m_json_col.Add("]", next_key)
        
        array_close_line = ""
        ret_val = Me.array
      Else
   
        ' Print "Unknown?"
        Raise DebugMessage("Ignoring Unknown Type at line " & Hex(m_line_no, m_line_no_width), LogLevel.Warning)
        
      End If
  End Select
 Return ret_val
End

Private Sub AddMember(pKey As String, pName As String, pValue As String, pType As Integer)
' Added to clean up some code, make it more readable and easier to maintain
' this is the repetitive functions found in the Select Case tree in function parse.
' I also set this up so in the future debugging can be turned on and off easier
      Dim sType As String
      m_line_no += 1
      ' These strings for the types must match what is in the icon collection. consider moving the collection of icons to this class.
      sType = Choose(pType, "Boolean", "Number", "String", "Array", "Object")
      sType = IIf(sType = Null, "Null", sType)
      pKey = IIf(pKey = "", "/", pKey) ' Make sure key value is not null
      If m_debug Then Raise DebugMessage(Hex(m_line_no, m_line_no_width) & " | " & pKey & " \"" & pName & "\" : " & IIf(CBool(pValue), "True", "False"), LogLevel.Info)
      Raise Added(pKey, pName, pValue, sType)
      m_json_col.Add(pValue, pKey)
      m_json_col.Default = IIf(m_members_count = 0, pValue, m_json_col.Default)
      m_members_count += 1
  
End


Private Function Value_Read() As Variant

  Return m_json_col.Default

End


Private Function Objects_Read() As Integer
'Returns the count or -1 if there is an error
  Return IIf(m_object_open_count - m_object_close_count = 0, m_object_close_count, -1)

End

Private Function Arrays_Read() As Integer
' Returns the number of arrays in the JSON or -1 if there is an error
  Return IIf(m_array_open_count - m_array_close_count = 0, m_array_close_count, -1)

End

Private Function NamedType_Read() As String

  Dim sBuffer As String
  
  sBuffer = Choose(m_js_type, "Boolean", "Number", "String", "Array", "Object")
  sBuffer = IIf(sBuffer = Null, "null", sBuffer)
  Return sBuffer

End

Private Function Members_Read() As Integer

  Return m_members_count

End


Function Type_Read() As Integer
  
  Return m_js_type
  
End

Private Function URL_Read() As String

  Return m_url

End

Private Sub URL_Write(Value As String)

  m_url = Value

End

Private Function LineNoWidth_Read() As Integer

  Return m_line_no_width

End

Private Sub LineNoWidth_Write(Value As Integer)

  m_line_no_width = Value

End

Private Function Debug_Read() As Integer

  Return m_debug

End

Private Sub Debug_Write(Value As Integer)

  m_debug = Value

End
